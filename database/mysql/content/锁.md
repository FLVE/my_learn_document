# 锁

## 1、全局锁

```sql
flush tables with read lock (FTWRL)
```

全库逻辑备份

```sql
mysqldump –single-transaction
# 使用该参数启动一个事务，确保拿到一致性视图
```

```sql
# 全库只读
set global readonly=true
# 1、有其他判断
# 2、异常处如果执行
# FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态理机制有差异
# 而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。

```

## 2、表级锁

一种是表锁，一种是元数据锁（meta data lock，MDL)

### 1、表锁

```sql
# 上锁
lock tables … read/write

# 解锁
unlock tables
```

### 2、元数据锁

在访问一个表的时候会被自动加上，保证读写的正确性

> 当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁

## 3、行锁

### 1、两阶段锁

**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

### 2、死锁和死锁等待

当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

### 3、解决死锁问题

1、确保业务不会有死锁，关闭死锁检测

2、控制并发度。相同行的更新，在进入引擎排队。



